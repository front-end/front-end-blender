#!/usr/bin/env ruby

# Copyright (c) 2008 Chris Griego
#           (c) 2008 Blake Elshire
# 
# Blender is freely distributable under the terms of an MIT-style license.
# For details, see http://www.opensource.org/licenses/mit-license.php

require 'yaml'
require 'optparse'
require 'rdoc/usage'
require 'ostruct'
require 'base64'
require 'benchmark'
require 'mime/types'
require 'find'

# TODO Move class to lib so other tools could potentially reuse it
class Blender
  VERSION = '0.8'
  
  attr_reader :options
  
  def initialize(arguments, stdin)
    @arguments = arguments
    
    # Set defaults
    @options = OpenStruct.new
    @options.blendfile = 'blender.yaml'
    @options.data      = false
    @options.force     = false
    @options.generate  = false
  end
  
  def blend
    if parsed_options?
      if @options.generate
        create_blendfile
      end
      
      elapsed = Benchmark.realtime do
        unless File.exists? @options.blendfile
          puts "Couldn't find '#{@options.blendfile}'"
          exit 1
        end
        
        blender = YAML::load_file @options.blendfile
        
        Dir.chdir(File.dirname(@options.blendfile))
        
        blender.each do |output_name, inputs|
          output_new = false
          
          # Checks the type flag and if the current file meets the type requirements continues
          if output_name.match "." + @options.file_type.to_s
            file_type = output_name.match(/\.css/) ? "css" : "js"
            
            # Checks if output file exists and checks the mtimes of the source files to the output file if new creates a new file
            if File.exists? output_name
              inputs.each do |i|
                if File.mtime(i) > File.mtime(output_name)
                  output_new = true
                  break
                end
              end
              
              if output_new || @options.force
                create_output(output_name, inputs, file_type)
              else
                puts "Skipping: #{output_name}"
              end
            else
              create_output(output_name, inputs, file_type)
            end
          end
        end
      end
      
      puts sprintf("%.5f", elapsed) + " seconds"
    end
  end
  
  protected
  
  def parsed_options?
    opts = OptionParser.new
    
    opts.on('-h',      '--help')                                                                                        {    output_help               }
    opts.on('-v',      '--version')                                                                                     {    output_version; exit 0    }
    opts.on('-f FILE', '--file FILE',   String,      "Use given Blendfile")                                             {|f| @options.blendfile = f    }
    opts.on('-t TYPE', '--type TYPE',   [:css, :js], "Select file type to blend (css, js)")                             {|t| @options.file_type = t    }
    opts.on('-d',      '--data',        String,      "Convert url(image.ext) to url(data:) in CSS files EXPERIMENTAL")  {    @options.data      = true }
    opts.on(           '--force',       String,      "Force blending when source files aren't newer than output files") {    @options.force     = true }
    opts.on(           '--yui=YUIOPTS', String,      "Pass arguments to YUI Compressor")                                {|o| @options.yuiopts   = o    }
    opts.on('-g',      '--generate',    String,      "Generate a stub Blendfile")                                       {    @options.generate  = true }
    
    opts.parse!(@arguments) rescue return false
    
    true
  end
  
  def create_blendfile
    if File.exists?(@options.blendfile) && !@options.force
      puts "'#{@options.blendfile}' already exists"
      exit 1
    end
    
    blend_files = Hash.new
    
    Find.find(Dir.getwd) do |f|
      if f.match /\.css$/
        key = File.dirname(f) + "-min.css"
        if blend_files.has_key? key
          blend_files[key] << f
        else
          blend_files[key] = [f]
        end
      end
      
      if f.match /\.js$/
        key = File.dirname(f) + "-min.js"
        if blend_files.has_key? key
          blend_files[key] << f
        else
          blend_files[key] = [f]
        end
      end
      
      Find.prune if File.basename(f).index('.') == 0
    end
    
    File.open(@options.blendfile, 'w') { |f| YAML.dump(blend_files, f) }
    
    exit 0
  end
  
  # TODO Change to work with directory hashes (css/: [ colors.css, layout.css ])
  def create_output(output_name, inputs, type)
    File.open(output_name, 'w') do |output_file|
      output = ''
      
      inputs.each do |i|
        output << IO.read(i)
      end
      
      # Compress
      real_file = File.symlink?(__FILE__) ? File.readlink(__FILE__) : __FILE__
      
      IO.popen("java -jar #{File.dirname(real_file)}/../lib/yui/yuicompressor.jar #{@options.yuiopts} --type #{type}", mode="r+") do |io|
        io.write output
        io.close_write
        
        output = io.read
        
        if output_name.match /\.css$/
          output.gsub! ' and(', ' and (' # Workaround for YUI Compressor Bug #1938329
          output.gsub! '/**/;}', '/**/}' # Workaround for YUI Compressor Bug #1961175
          
          if @options.data
            output = output.gsub(/url\(['"]?([^?']+)['"]+\)/im) do
              uri = $1
              mime_type = ''
              
              # Make the URI absolute instead of relative. TODO Seems kinda hacky is there a better way?
              uri.gsub! "../", ""
              
              # Figure out the mime type.
              mime_type = MIME::Types.type_for(uri)
              
              url_contents = make_data_uri(IO.read(uri), mime_type[0])
              
              %Q!url("#{url_contents}")!
            end
          end
        end
        
        output_file << output
      end
    end
    
    puts output_name
  end
  
  def make_data_uri(content, content_type)
    outuri   = 'data:' + content_type + ';base64'
    content  = Base64.encode64(content)
    outuri  += ",#{content}"
    
    outuri.gsub("\n", '')
  end
  
  def output_version
    puts "Blender v#{VERSION}"
  end
  
  def output_help
    output_version
    RDoc::usage() #exits app
  end
end

# Create and run the application
blender = Blender.new(ARGV, STDIN)
blender.blend
