#!/usr/bin/env ruby
# == Synopsis 
#   Blender is like Make or Ant for the front-end. It aggregates and compresses
#   CSS and/or JavaScript assets of a site into production-ready files.
# 
# == Examples
#   In your site directory run blender to minify CSS and JavaScript.
#     blender
# 
#   Other examples:
#     blender -f site/blender.yaml
#     blender -t css
#     blender -t css -d
# 
# == Usage 
#   blender [options]
# 
#   For help use: blender -h
# 
# == Options
#   -h, --help                     Displays help message
#   -v, --version                  Display the version, then exit
#   -f <file>, --file <file>       Use given Blendfile
#   -t <css|js>, --type <css|js>   Compress CSS or JavaScript only
#   -d, --data                     Convert CSS url(image.ext) to url(data:) EXPERIMENTAL
#   -F, --force                    Force file minification when there are no new updates
# 
# == Authors
#   Chris Griego & Blake Elshire
# 
# == Installation
#   To install the beta version, run the following at the command line:
#     sudo gem install cgriego-blender --source=http://gems.github.com
# 
# == License
#   Copyright (c) 2008 Chris Griego & Blake Elshire.
#   Licensed under the MIT License:
#   http://www.opensource.org/licenses/mit-license.php


require 'yaml'
require 'optparse'
require 'rdoc/usage'
require 'ostruct'
require 'base64'

class Blender
  VERSION = '0.5.1'
  attr_reader :options
  
  def initialize(arguments, stdin)
    @arguments = arguments
    # Set defaults
    @options = OpenStruct.new
    @options.blendfile = 'blender.yaml'
    @options.png       = false
    @options.data      = false
    @options.force     = false
  end
  
  def blend
    if parsed_options?
      unless File.exists? @options.blendfile
        puts "Couldn't find '#{@options.blendfile}'"
        exit 1
      end
      
      blender = YAML::load_file @options.blendfile
      
      Dir.chdir(File.dirname(@options.blendfile))
      
      blender.each do |output_name, inputs|
        output_new = false
        # Checks the type flag and if the current file meets the type requirements continues
        if output_name.match "." + @options.file_type.to_s
          
          file_type = output_name.match(/\.css/) ? "css" : "js"
          
          # Checks if output file exists and checks the mtimes of the source files to the output file if new creates a new file
          if File.exists? output_name
            inputs.each do |i|
              if File.mtime(i) > File.mtime(output_name)
                output_new = true
                break
              end
            end
            
            if output_new || @options.force
                create_output(output_name, inputs, file_type)
            else
                puts "Skipping: #{output_name}"
            end
          else
              create_output(output_name, inputs, file_type)
          end
        end
      end
    end
  end
  
  protected
  
    def parsed_options?
      opts = OptionParser.new
      opts.on('-v', '--version') { output_version ; exit 0 }
      opts.on('-h', '--help')    { output_help }
      opts.on('-f FILE', '--file FILE', String, "Use given Blendfile") do |blendfile|
        @options.blendfile = blendfile
      end
      opts.on("-t [TYPE]", "--type [TYPE]", [:css, :js], "Select file type to minify (css, js)") do |t|
        @options.file_type = t
      end
      opts.on("-d", "--data", String, "Change url(image.ext) to url(data:) in css files") { @options.data = true }
      opts.on("-F", "--force", String, "Force minification when source files aren't newer than min files") { @options.force = true }
      
      opts.parse!(@arguments) rescue return false
      true
    end
    
    # TODO Change to work with directory hashes (css/: [ colors.css, layout.css ])
    def create_output(output_name, inputs, type)
      File.open(output_name, 'w') do |output_file|
        inputs.each do |i|
          output_file << IO.read(i)
        end
      end
      
      # Compress
      IO.popen("java -jar #{File.dirname(__FILE__)}/../lib/yuicompressor.jar --type #{type}", mode="r+") do |io|
        io.write IO.read(output_name)
        io.close_write
        File.open(output_name, 'w') do |output_file|
          output_file << io.read
        end
      end
      
      # Workaround for YUI Compressor Bug #1938329 & Bug #1961175
      if output_name.match /\.css$/
        output = IO.read(output_name)
        output.gsub! ' and(', ' and ('
        output.gsub! '/**/;}', '/**/}'
        
        if @options.data
          output = output.gsub(/url\(['"]?([^?']+)['"]+\)/im) {
            uri = $1
            mime_type = ''
            
            # Make the URI absolute instead of relative. TODO Again seems kinda hacky is there a better way?
            uri.gsub! "../", ""

            # Figure out the mime type. TODO Seems hacky is there a way to read mime type built into Ruby?
            IO.popen("file --mime #{uri}") do |io|
              mime_type = io.read.split(": ")[1]
            end
            
            url_contents = make_data_uri(IO.read(uri), mime_type)
            
            %Q!url("#{url_contents}")!
          }
        end
        
        File.open(output_name, 'w') do |output_file|
          output_file << output
        end
      end
      puts output_name
    end
    
    def make_data_uri(content, content_type)
      outuri = 'data:' + content_type + ';base64'
      content = Base64.encode64(content)
      outuri += ",#{content}"
      return outuri.gsub("\n", '')
    end
    
    def output_version
      puts "#{File.basename(__FILE__)} version #{VERSION}"
    end
    
    def output_help
      output_version
      RDoc::usage() #exits app
    end
end

# Create and run the application
blender = Blender.new(ARGV, STDIN)
blender.blend
